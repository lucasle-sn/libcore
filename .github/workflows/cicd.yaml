name: CI/CD Pipeline

on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - '*'

env:
  BUILD_DEPENDENCIES: g++ cmake build-essential checkinstall zlib1g-dev libssl-dev
  BUILD_DIRECTORY: build

jobs:
  # build-ubuntu:
  #   runs-on: ubuntu-latest
  #   strategy:
  #     matrix:
  #       build-type: [DEBUG, RELEASE]
  #   name: Build & Test <${{ matrix.build-type }}>
  #   timeout-minutes: 30
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4
  #       with:
  #         ref: ${{ github.event.pull_request.head.sha }}
  #         submodules: true

  #     - name: Install dependencies
  #       run: sudo apt-get install -y ${{ env.BUILD_DEPENDENCIES }}

  #     - name: Build
  #       run: |
  #         if [ "${{matrix.build-type}}" == "DEBUG" ]; then
  #           cmake -S . -B ${{ env.BUILD_DIRECTORY }} -DCMAKE_BUILD_TYPE=Debug && cmake --build ${{ env.BUILD_DIRECTORY }} -j10
  #         else
  #           cmake -S . -B ${{ env.BUILD_DIRECTORY }} -DCMAKE_BUILD_TYPE=Release && cmake --build ${{ env.BUILD_DIRECTORY }} -j10
  #         fi

  #     - name: Test
  #       run: cd ${{ env.BUILD_DIRECTORY }} && ctest -j8 -T test --no-compress-output

  # extra-checks:
  #   runs-on: ubuntu-latest
  #   needs: [build-ubuntu]
  #   name: Extra Checks
  #   timeout-minutes: 10
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4
  #       with:
  #         ref: ${{ github.event.pull_request.head.sha }}
  #         submodules: true

  #     - name: Install dependencies
  #       run: sudo apt-get install -y ${{ env.BUILD_DEPENDENCIES }} doxygen graphviz clang-format 

  #     - name: Check clang-format
  #       run: |
  #         FILES=$(find . -not -path "./third_party/*" -not -path "./build/*" \( -name '*.cc' -o -name '*.c' -o -name '*.h' \))
  #         TMPFILE="./formatted_file"
  #         for file in $FILES; do
  #           clang-format -style=file $file > $TMPFILE
  #           if ! diff $file $TMPFILE > /dev/null; then
  #             echo "Clang-format failed on $file"
  #             rm $TMPFILE
  #             exit 1
  #           fi 
  #           rm $TMPFILE
  #         done
  #         echo "Clang-format check successful"

  #     - name: Check doxygen
  #       run: |
  #         cmake -S . -B ${{ env.BUILD_DIRECTORY }} -DCMAKE_BUILD_TYPE=Debug -DDOXYGEN_BUILD_ENABLED=ON
  #         cmake --build ${{ env.BUILD_DIRECTORY }} --target doxygen -- --no-print-directory

  sonar-cloud:
    name: Sonarcloud Analysis
    runs-on: ubuntu-latest
    # needs: [build-ubuntu]
    env:
      BUILD_WRAPPER_OUT_DIR: build_wrapper_output_directory
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true

      - name: Install dependencies
        run: sudo apt-get install -y ${{ env.BUILD_DEPENDENCIES }} lcov gcovr

      - name: Install sonar-scanner and build-wrapper
        uses: SonarSource/sonarcloud-github-c-cpp@v2

      - name: Run build-wrapper
        run: |
          cmake -S . -B ${{ env.BUILD_DIRECTORY }} -DCODE_COVERAGE=ON -DCMAKE_C_FLAGS=--coverage -DCMAKE_CXX_FLAGS=--coverage
          build-wrapper-linux-x86-64 --out-dir ${{ env.BUILD_WRAPPER_OUT_DIR }} cmake --build ${{ env.BUILD_DIRECTORY }} -j10

      - name: Generate coverage information
        run: |
          # Run tests to generate coverage information
          cd ${{ env.BUILD_DIRECTORY }} && ctest -j8 -T test --no-compress-output

          # lcov --capture --directory . --output-file coverage.info
          # lcov --remove coverage.info '/usr/*' --output-file coverage.info
          # lcov --list coverage.info

          gcovr -r .. --sonarqube -o coverage.xml --exclude '../third_party/.*'
          cat coverage.xml

      # - name: Upload code coverage report to Codecov
      #   uses: codecov/codecov-action@v2
      #   with:
      #     files: ${{ env.BUILD_DIRECTORY }}/coverage.info

      - name: Run sonar-scanner
        # uses: SonarSource/sonarcloud-github-action@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        # with:
        #   projectBaseDir: ${{ env.BUILD_DIRECTORY }}
        #   args: >
        #     -Dsonar.organization=${{ secrets.SONAR_ORG }}
        #     -Dsonar.projectKey=${{ secrets.SONAR_PROJECT_KEY }}
        #     -Dsonar.sources=../**/src
        #     -Dsonar.tests=../**/test
        #     -Dsonar.coverage.exclusions=../third_party
        #     -Dsonar.cfamily.build-wrapper-output=build_wrapper_output_directory
        run: |
          sonar-scanner \
            -Dsonar.cfamily.compile-commands="${{ env.BUILD_WRAPPER_OUT_DIR }}/compile_commands.json" \
            -Dsonar.coverageReportPaths=${{ env.BUILD_DIRECTORY }}/coverage.xml \
            -Dsonar.sources=./ \
            -Dsonar.tests=./ \
            -Dsonar.test.inclusions=**/test/**/* \
            -Dsonar.exclusions=**/test/**/*
            # -Dsonar.sources=**/src,**/include \
            # -Dsonar.tests=**/test
            # -Dsonar.coverage.exclusions=./third_party \
